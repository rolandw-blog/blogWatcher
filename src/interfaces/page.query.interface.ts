// These are all the valid query parameters when searching for a page with MONGOOSE
// Note that there is another type of pagination, which is seperate because pagination is generated by the server if required

// Used in the IPageQuery interface below to provide types for the allowed meta.pathLength values
type pathLength = { $gte?: number; $lte?: number; $eq?: number };

// Support up to 10 pages deep
type PageNumber = "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "10";

// typescript index signatures for 1.path, 2.path, 3.path, etc.
type IndexedPath = `path.${PageNumber}`;

// Create an interface with an index signature for
interface PathSeries {
	[key: string]: IndexedPath;
}

interface IPageQueryParamsKnownFields {
	_id?: string;
	name?: RegExp;
	// this is how mongoose stores nested objects for queries
	// dont use ?meta.template=templateName
	// instead use ?template=templateName and the controller will transform it for you
	"meta.template"?: string;
	// the path length is set through the controller with a wildcard
	// EG ?path = /my/path/here/* will match { eq: 3 } (paths of length 3)
	// EG ?path = /my/path/here will match { eq: 2 } (paths of length 2)
	"meta.pathLength"?: pathLength;
}

// combine the known fields with the path fields "1.path", "2.path"... etc
// this creates an object that that combines the known fields with the path fields
type IPageQueryParams = IPageQueryParamsKnownFields & PathSeries;

export { IndexedPath };
export default IPageQueryParams;
